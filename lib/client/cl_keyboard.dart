/*
 * Copyright (C) 1997-2001 Id Software, Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
 * USA.
 *
 * =======================================================================
 *
 * Upper layer of the keyboard implementation. This file processes all
 * keyboard events which are generated by the low level keyboard layer.
 * Remeber, that the mouse is handled by the refresher and not by the
 * client!
 *
 * =======================================================================
 */
import 'package:dQuakeWeb/common/clientserver.dart';
import 'package:dQuakeWeb/common/cmdparser.dart';
import 'package:dQuakeWeb/common/cvar.dart';
import 'package:dQuakeWeb/shared/shared.dart';
import 'client.dart';
import 'menu/menu.dart' show M_Keydown, M_Menu_Main_f;
import 'cl_console.dart' show Con_ToggleConsole_f;

/* number of console command lines saved in history,
 * must be a power of two, because we use & (NUM_KEY_LINES-1)
 * instead of % so -1 wraps to NUM_KEY_LINES-1 */
const NUM_KEY_LINES = 32;


/* these are the key numbers that should be passed to Key_Event
   they must be mached by the low level key event processing! */
const K_TAB = 9;
const K_ENTER = 13;
const K_ESCAPE = 27;
const K_SPACE = 32;

const K_BACKSPACE = 127;

const K_COMMAND = 128;
const K_CAPSLOCK = 129;
const K_POWER = 130;
const K_PAUSE = 131;

const K_UPARROW = 132;
const K_DOWNARROW = 133;
const K_LEFTARROW = 134;
const K_RIGHTARROW = 135;

const K_ALT = 136;
const K_CTRL = 137;
const K_SHIFT = 138;
const K_INS = 139;
const K_DEL = 140;
const K_PGDN = 141;
const K_PGUP = 142;
const K_HOME = 143;
const K_END = 144;

const K_F1 = 145;
const K_F2 = 146;
const K_F3 = 147;
const K_F4 = 148;
const K_F5 = 149;
const K_F6 = 150;
const K_F7 = 151;
const K_F8 = 152;
const K_F9 = 153;
const K_F10 = 154;
const K_F11 = 155;
const K_F12 = 156;
const K_F13 = 157;
const K_F14 = 158;
const K_F15 = 159;

const K_KP_HOME = 160;
const K_KP_UPARROW = 161;
const K_KP_PGUP = 162;
const K_KP_LEFTARROW = 163;
const K_KP_5 = 164;
const K_KP_RIGHTARROW = 165;
const K_KP_END = 166;
const K_KP_DOWNARROW = 167;
const K_KP_PGDN = 168;
const K_KP_ENTER = 169;
const K_KP_INS = 170;
const K_KP_DEL = 171;
const K_KP_SLASH = 172;
const K_KP_MINUS = 173;
const K_KP_PLUS = 174;
const K_KP_NUMLOCK = 175;
const K_KP_STAR = 176;
const K_KP_EQUALS = 177;

const K_MOUSE1 = 178;
const K_MOUSE2 = 179;
const K_MOUSE3 = 180;
const K_MOUSE4 = 181;
const K_MOUSE5 = 182;

const K_MWHEELDOWN = 183;
const K_MWHEELUP = 184;

const K_JOY1 = 185;
const K_JOY2 = 186;
const K_JOY3 = 187;
const K_JOY4 = 188;
const K_JOY5 = 189;
const K_JOY6 = 190;
const K_JOY7 = 191;
const K_JOY8 = 192;
const K_JOY9 = 193;
const K_JOY10 = 194;
const K_JOY11 = 195;
const K_JOY12 = 196;
const K_JOY13 = 197;
const K_JOY14 = 198;
const K_JOY15 = 199;
const K_JOY16 = 200;
const K_JOY17 = 201;
const K_JOY18 = 202;
const K_JOY19 = 203;
const K_JOY20 = 204;
const K_JOY21 = 205;
const K_JOY22 = 206;
const K_JOY23 = 207;
const K_JOY24 = 208;
const K_JOY25 = 209;
const K_JOY26 = 210;
const K_JOY27 = 211;
const K_JOY28 = 212;
const K_JOY29 = 213;
const K_JOY30 = 214;
const K_JOY31 = 215;
const K_JOY32 = 216;

const K_HAT_UP = 217;
const K_HAT_RIGHT = 218;
const K_HAT_DOWN = 219;
const K_HAT_LEFT = 220;

const K_TRIG_LEFT = 221;
const K_TRIG_RIGHT = 222;

// add other joystick/controller keys before this one
// and adjust it accordingly, also remember to add corresponding _ALT key below!
const K_JOY_LAST_REGULAR = K_TRIG_RIGHT;

/* Can't be mapped to any action (=> not regular) */
const K_JOY_BACK = 223;

const K_JOY1_ALT = 224;
const K_JOY2_ALT = 225;
const K_JOY3_ALT = 226;
const K_JOY4_ALT = 227;
const K_JOY5_ALT = 228;
const K_JOY6_ALT = 229;
const K_JOY7_ALT = 230;
const K_JOY8_ALT = 231;
const K_JOY9_ALT = 232;
const K_JOY10_ALT = 233;
const K_JOY11_ALT = 234;
const K_JOY12_ALT = 235;
const K_JOY13_ALT = 236;
const K_JOY14_ALT = 237;
const K_JOY15_ALT = 238;
const K_JOY16_ALT = 239;
const K_JOY17_ALT = 240;
const K_JOY18_ALT = 241;
const K_JOY19_ALT = 242;
const K_JOY20_ALT = 243;
const K_JOY21_ALT = 244;
const K_JOY22_ALT = 245;
const K_JOY23_ALT = 246;
const K_JOY24_ALT = 247;
const K_JOY25_ALT = 248;
const K_JOY26_ALT = 249;
const K_JOY27_ALT = 250;
const K_JOY28_ALT = 251;
const K_JOY29_ALT = 252;
const K_JOY30_ALT = 253;
const K_JOY31_ALT = 254;
const K_JOY32_ALT = 255;

const K_HAT_UP_ALT = 256;
const K_HAT_RIGHT_ALT = 257;
const K_HAT_DOWN_ALT = 258;
const K_HAT_LEFT_ALT = 259;

const K_TRIG_LEFT_ALT = 260;
const K_TRIG_RIGHT_ALT = 261;

// add other joystick/controller keys before this one and adjust it accordingly
const K_JOY_LAST_REGULAR_ALT = K_TRIG_RIGHT_ALT;

const K_AUX1 = 262;
const K_AUX2 = 263;
const K_AUX3 = 264;
const K_AUX4 = 265;
const K_AUX5 = 266;
const K_AUX6 = 267;
const K_AUX7 = 268;
const K_AUX8 = 269;
const K_AUX9 = 270;
const K_AUX10 = 271;
const K_AUX11 = 272;
const K_AUX12 = 273;
const K_AUX13 = 274;
const K_AUX14 = 275;
const K_AUX15 = 276;
const K_AUX16 = 277;
const K_AUX17 = 278;
const K_AUX18 = 279;
const K_AUX19 = 280;
const K_AUX20 = 281;
const K_AUX21 = 282;
const K_AUX22 = 283;
const K_AUX23 = 284;
const K_AUX24 = 285;
const K_AUX25 = 286;
const K_AUX26 = 287;
const K_AUX27 = 288;
const K_AUX28 = 289;
const K_AUX29 = 290;
const K_AUX30 = 291;
const K_AUX31 = 292;
const K_AUX32 = 293;

const K_SUPER = 294;
const K_COMPOSE = 295;
const K_MODE = 296;
const K_HELP = 297;
const K_PRINT = 298;
const K_SYSREQ = 299;
const K_SCROLLOCK = 300;
const K_MENU = 301;
const K_UNDO = 302;

const K_LAST = 303;

/* Translates internal key representations
 * into human readable strings. */
final keynames = {
	"TAB": K_TAB,
	"ENTER": K_ENTER,
	"ESCAPE": K_ESCAPE,
	"SPACE": K_SPACE,
	"BACKSPACE": K_BACKSPACE,

	"COMMAND": K_COMMAND,
	"CAPSLOCK": K_CAPSLOCK,
	"POWER": K_POWER,
	"PAUSE": K_PAUSE,

	"UPARROW": K_UPARROW,
	"DOWNARROW": K_DOWNARROW,
	"LEFTARROW": K_LEFTARROW,
	"RIGHTARROW": K_RIGHTARROW,

	"ALT": K_ALT,
	"CTRL": K_CTRL,
	"SHIFT": K_SHIFT,

	"F1": K_F1,
	"F2": K_F2,
	"F3": K_F3,
	"F4": K_F4,
	"F5": K_F5,
	"F6": K_F6,
	"F7": K_F7,
	"F8": K_F8,
	"F9": K_F9,
	"F10": K_F10,
	"F11": K_F11,
	"F12": K_F12,

	"INS": K_INS,
	"DEL": K_DEL,
	"PGDN": K_PGDN,
	"PGUP": K_PGUP,
	"HOME": K_HOME,
	"END": K_END,

	"MOUSE1": K_MOUSE1,
	"MOUSE2": K_MOUSE2,
	"MOUSE3": K_MOUSE3,
	"MOUSE4": K_MOUSE4,
	"MOUSE5": K_MOUSE5,

	"JOY1": K_JOY1,
	"JOY2": K_JOY2,
	"JOY3": K_JOY3,
	"JOY4": K_JOY4,
	"JOY5": K_JOY5,
	"JOY6": K_JOY6,
	"JOY7": K_JOY7,
	"JOY8": K_JOY8,
	"JOY9": K_JOY9,
	"JOY10": K_JOY10,
	"JOY11": K_JOY11,
	"JOY12": K_JOY12,
	"JOY13": K_JOY13,
	"JOY14": K_JOY14,
	"JOY15": K_JOY15,
	"JOY16": K_JOY16,
	"JOY17": K_JOY17,
	"JOY18": K_JOY18,
	"JOY19": K_JOY19,
	"JOY20": K_JOY20,
	"JOY21": K_JOY21,
	"JOY22": K_JOY22,
	"JOY23": K_JOY23,
	"JOY24": K_JOY24,
	"JOY25": K_JOY25,
	"JOY26": K_JOY26,
	"JOY27": K_JOY27,
	"JOY28": K_JOY28,
	"JOY29": K_JOY29,
	"JOY30": K_JOY30,
	"JOY31": K_JOY31,
	"JOY32": K_JOY32,

	"HAT_UP": K_HAT_UP,
	"HAT_RIGHT": K_HAT_RIGHT,
	"HAT_DOWN": K_HAT_DOWN,
	"HAT_LEFT": K_HAT_LEFT,

	"TRIG_LEFT": K_TRIG_LEFT,
	"TRIG_RIGHT": K_TRIG_RIGHT,

	// virtual keys you get by pressing the corresponding normal joy key
	// and the altselector key
	"JOY1_ALT": K_JOY1_ALT,
	"JOY2_ALT": K_JOY2_ALT,
	"JOY3_ALT": K_JOY3_ALT,
	"JOY4_ALT": K_JOY4_ALT,
	"JOY5_ALT": K_JOY5_ALT,
	"JOY6_ALT": K_JOY6_ALT,
	"JOY7_ALT": K_JOY7_ALT,
	"JOY8_ALT": K_JOY8_ALT,
	"JOY9_ALT": K_JOY9_ALT,
	"JOY10_ALT": K_JOY10_ALT,
	"JOY11_ALT": K_JOY11_ALT,
	"JOY12_ALT": K_JOY12_ALT,
	"JOY13_ALT": K_JOY13_ALT,
	"JOY14_ALT": K_JOY14_ALT,
	"JOY15_ALT": K_JOY15_ALT,
	"JOY16_ALT": K_JOY16_ALT,
	"JOY17_ALT": K_JOY17_ALT,
	"JOY18_ALT": K_JOY18_ALT,
	"JOY19_ALT": K_JOY19_ALT,
	"JOY20_ALT": K_JOY20_ALT,
	"JOY21_ALT": K_JOY21_ALT,
	"JOY22_ALT": K_JOY22_ALT,
	"JOY23_ALT": K_JOY23_ALT,
	"JOY24_ALT": K_JOY24_ALT,
	"JOY25_ALT": K_JOY25_ALT,
	"JOY26_ALT": K_JOY26_ALT,
	"JOY27_ALT": K_JOY27_ALT,
	"JOY28_ALT": K_JOY28_ALT,
	"JOY29_ALT": K_JOY29_ALT,
	"JOY30_ALT": K_JOY30_ALT,
	"JOY31_ALT": K_JOY31_ALT,
	"JOY32_ALT": K_JOY32_ALT,

	"HAT_UP_ALT": K_HAT_UP_ALT,
	"HAT_RIGHT_ALT": K_HAT_RIGHT_ALT,
	"HAT_DOWN_ALT": K_HAT_DOWN_ALT,
	"HAT_LEFT_ALT": K_HAT_LEFT_ALT,

	"TRIG_LEFT": K_TRIG_LEFT_ALT,
	"TRIG_RIGHT": K_TRIG_RIGHT_ALT,

	"JOY_BACK": K_JOY_BACK,

	"AUX1": K_AUX1,
	"AUX2": K_AUX2,
	"AUX3": K_AUX3,
	"AUX4": K_AUX4,
	"AUX5": K_AUX5,
	"AUX6": K_AUX6,
	"AUX7": K_AUX7,
	"AUX8": K_AUX8,
	"AUX9": K_AUX9,
	"AUX10": K_AUX10,
	"AUX11": K_AUX11,
	"AUX12": K_AUX12,
	"AUX13": K_AUX13,
	"AUX14": K_AUX14,
	"AUX15": K_AUX15,
	"AUX16": K_AUX16,
	"AUX17": K_AUX17,
	"AUX18": K_AUX18,
	"AUX19": K_AUX19,
	"AUX20": K_AUX20,
	"AUX21": K_AUX21,
	"AUX22": K_AUX22,
	"AUX23": K_AUX23,
	"AUX24": K_AUX24,
	"AUX25": K_AUX25,
	"AUX26": K_AUX26,
	"AUX27": K_AUX27,
	"AUX28": K_AUX28,
	"AUX29": K_AUX29,
	"AUX30": K_AUX30,
	"AUX31": K_AUX31,
	"AUX32": K_AUX32,

	"KP_HOME": K_KP_HOME,
	"KP_UPARROW": K_KP_UPARROW,
	"KP_PGUP": K_KP_PGUP,
	"KP_LEFTARROW": K_KP_LEFTARROW,
	"KP_5": K_KP_5,
	"KP_RIGHTARROW": K_KP_RIGHTARROW,
	"KP_END": K_KP_END,
	"KP_DOWNARROW": K_KP_DOWNARROW,
	"KP_PGDN": K_KP_PGDN,
	"KP_ENTER": K_KP_ENTER,
	"KP_INS": K_KP_INS,
	"KP_DEL": K_KP_DEL,
	"KP_SLASH": K_KP_SLASH,
	"KP_STAR": K_KP_STAR,
	"KP_MINUS": K_KP_MINUS,
	"KP_PLUS": K_KP_PLUS,

	"MWHEELUP": K_MWHEELUP,
	"MWHEELDOWN": K_MWHEELDOWN,

	"PAUSE": K_PAUSE,

	"SEMICOLON": ';' /* because a raw semicolon seperates commands */
};

cvar_t cfg_unbindall;

/*
 * key up events are sent even if in console mode
 */

List<String> key_lines = List.generate(NUM_KEY_LINES, (i) => "");
int key_linepos = 0;
int anykeydown = 0;

int edit_line = 0;
int history_line = 0;

int key_waiting = 0;
List<String> keybindings = List.generate(K_LAST, (i) => "");
List<bool> consolekeys = List.generate(K_LAST, (i) => false); /* if true, can't be rebound while in console */
List<bool> menubound = List.generate(K_LAST, (i) => false); /* if true, can't be rebound while in menu */
List<int> key_repeats = List.generate(K_LAST, (i) => 0); /* if > 1, it is autorepeating */
List<bool> keydown = List.generate(K_LAST, (i) => false);

/*
 * Returns a key number to be used to index
 * keybindings[] by looking at the given string.
 * Single ascii characters return themselves, while
 * the K_* names are matched up.
 */
int Key_StringToKeynum(String str) {
	if (str == null || str.isEmpty) {
		return -1;
	}

	if (str.length == 1) {
		return str.codeUnitAt(0);
	}

  final kn = keynames[str.toUpperCase()];
  if (kn != null) {
    return kn;
  }
	return -1;
}

/*
 * Returns a string (either a single ascii char,
 * or a K_* name) for the given keynum.
 */
String Key_KeynumToString(int keynum) {

	if (keynum == -1) {
		return "<KEY NOT FOUND>";
	}

	if ((keynum > 32) && (keynum < 127)) {
		/* printable ascii */
		return String.fromCharCode(keynum);
	}

  for (var kn in keynames.entries) {
    if (kn.value == keynum) {
      return kn.key;
    }
  }
	return "<UNKNOWN KEYNUM>";
}

Key_SetBinding(int keynum, String binding) {

	if (keynum == -1) {
		return;
	}

	/* allocate memory for new binding */
	keybindings[keynum] = binding;
}

Key_Unbind_f(List<String> args) async {

	if (args.length != 2) {
		Com_Printf("unbind <key> : remove commands from a key\n");
		return;
	}

	final b = Key_StringToKeynum(args[1]);
	if (b == -1) {
		Com_Printf("\"${args[1]}\" isn't a valid key\n");
		return;
	}

	Key_SetBinding(b, null);
}

Key_Unbindall_f(List<String> args) async {

	for (int i = 0; i < K_LAST; i++) {
    Key_SetBinding(i, null);
	}
}

/* ugly hack, set in Cmd_ExecuteString() when yq2.cfg is executed
 * (=> default.cfg is done) */
// extern qboolean doneWithDefaultCfg;

Key_Bind_f(List<String> args) async {

	if (args.length < 2) {
		Com_Printf("bind <key> [command] : attach a command to a key\n");
		return;
	}

	final b = Key_StringToKeynum(args[1]);
	if (b == -1)
	{
		Com_Printf("\"${args[1]}\" isn't a valid key\n");
		return;
	}

	/* don't allow binding escape or the special console keys */
	if(b == K_ESCAPE || b == '^'.codeUnitAt(0) || b == '`'.codeUnitAt(0) || b == '~'.codeUnitAt(0) || b == K_JOY_BACK) {
		// if(doneWithDefaultCfg)
		// {
			/* don't warn about this when it's from default.cfg, we can't change that anyway */
			Com_Printf("You can't bind the special key \"${args[1]}\"!\n");
		// }
		return;
	}

	if (args.length == 2) {
		if (keybindings[b] != null) {
			Com_Printf("\"${args[1]}\" = \"${keybindings[b]}\"\n");
		} else {
			Com_Printf("\"${args[1]}\" is not bound\n");
		}
		return;
	}

	/* copy the rest of the command line */
	var cmd = StringBuffer(); /* start out with a null string */

	for (int i = 2; i < args.length; i++) {
		cmd.write(args[i]);

		if (i != (args.length - 1)) {
			cmd.write(" ");
		}
	}

	Key_SetBinding(b, cmd.toString());
}

Key_Bindlist_f(List<String> args) {
	for (int i = 0; i < K_LAST; i++) {
		if (keybindings[i] != null && keybindings[i].isNotEmpty) {
			Com_Printf("${Key_KeynumToString(i)} \"${keybindings[i]}\"\n");
		}
	}
}


Key_Init() {
	for (int i = 0; i < NUM_KEY_LINES; i++) {
		key_lines[i] = ']';
	}
	// can't call Key_ReadConsoleHistory() here because FS_Gamedir() isn't set yet

	key_linepos = 1;

	/* init 128 bit ascii characters in console mode */
	for (int i = 32; i < 128; i++) {
		consolekeys[i] = true;
	}

	consolekeys[K_ENTER] = true;
	consolekeys[K_KP_ENTER] = true;
	consolekeys[K_TAB] = true;
	consolekeys[K_LEFTARROW] = true;
	consolekeys[K_KP_LEFTARROW] = true;
	consolekeys[K_RIGHTARROW] = true;
	consolekeys[K_KP_RIGHTARROW] = true;
	consolekeys[K_UPARROW] = true;
	consolekeys[K_KP_UPARROW] = true;
	consolekeys[K_DOWNARROW] = true;
	consolekeys[K_KP_DOWNARROW] = true;
	consolekeys[K_BACKSPACE] = true;
	consolekeys[K_HOME] = true;
	consolekeys[K_KP_HOME] = true;
	consolekeys[K_END] = true;
	consolekeys[K_KP_END] = true;
	consolekeys[K_PGUP] = true;
	consolekeys[K_KP_PGUP] = true;
	consolekeys[K_PGDN] = true;
	consolekeys[K_KP_PGDN] = true;
	consolekeys[K_SHIFT] = true;
	consolekeys[K_INS] = true;
	consolekeys[K_KP_INS] = true;
	consolekeys[K_KP_DEL] = true;
	consolekeys[K_KP_SLASH] = true;
	consolekeys[K_KP_STAR] = true;
	consolekeys[K_KP_PLUS] = true;
	consolekeys[K_KP_MINUS] = true;
	consolekeys[K_KP_5] = true;
	consolekeys[K_MWHEELUP] = true;
	consolekeys[K_MWHEELDOWN] = true;
	consolekeys[K_MOUSE4] = true;
	consolekeys[K_MOUSE5] = true;

	consolekeys['`'.codeUnitAt(0)] = false;
	consolekeys['~'.codeUnitAt(0)] = false;
	consolekeys['^'.codeUnitAt(0)] = false;

	menubound[K_ESCAPE] = true;

	for (int i = 0; i < 12; i++) {
		menubound[K_F1 + i] = true;
	}

	// /* register our variables */
	cfg_unbindall = Cvar_Get("cfg_unbindall", "1", CVAR_ARCHIVE);

	/* register our functions */
	Cmd_AddCommand("bind", Key_Bind_f);
	Cmd_AddCommand("unbind", Key_Unbind_f);
	Cmd_AddCommand("unbindall", Key_Unbindall_f);
	Cmd_AddCommand("bindlist", Key_Bindlist_f);
}

/*
 * Called every frame for every detected keypress.
 * This is only for movement and special characters,
 * anything else is handled by Char_Event().
 */
Key_Event(int key, bool down, bool special) async {
  if (key < 0) return;

	final time = Sys_Milliseconds();

	// evil hack for the joystick key altselector, which turns K_JOYx into K_JOYx_ALT
	// if(joy_altselector_pressed && key >= K_JOY1 && key <= K_JOY_LAST_REGULAR)
	// {
	// 	// make sure key is not the altselector itself (which we won't turn into *_ALT)
	// 	if(keybindings[key] == NULL || strcmp(keybindings[key], "+joyaltselector") != 0)
	// 	{
	// 		int altkey = key + (K_JOY1_ALT - K_JOY1);
	// 		// allow fallback to binding with non-alt key
	// 		if(keybindings[altkey] != NULL || keybindings[key] == NULL)
	// 			key = altkey;
	// 	}
	// }

	/* Track if key is down */
	keydown[key] = down;

	/* Ignore most autorepeats */
	if (down) {
		key_repeats[key]++;

		if ((key != K_BACKSPACE) &&
			(key != K_PAUSE) &&
			(key != K_PGUP) &&
			(key != K_KP_PGUP) &&
			(key != K_PGDN) &&
			(key != K_KP_PGDN) &&
			(key_repeats[key] > 1)) {
			return;
		}
	} else {
		key_repeats[key] = 0;
	}

	/* Fullscreen switch through Alt + Return */
	if (down && keydown[K_ALT] && key == K_ENTER) {
	// 	fullscreen = Cvar_Get("vid_fullscreen", "0", CVAR_ARCHIVE);

	// 	if (!fullscreen->value)
	// 	{
	// 		Cvar_Set("vid_fullscreen", "1");
	// 		fullscreen->modified = true;
	// 	}
	// 	else
	// 	{
	// 		Cvar_Set("vid_fullscreen", "0");
	// 		fullscreen->modified = true;
	// 	}

		return;
	}

	/* Toogle console though Shift + Escape */
	if (down && keydown[K_SHIFT] && key == K_ESCAPE) {
		await Con_ToggleConsole_f([]);
		return;
	}

	// /* Key is unbound */
	// if ((key >= K_MOUSE1 && key != K_JOY_BACK) && !keybindings[key] && (cls.key_dest != key_console) &&
	// 	(cls.state == ca_active))
	// {
	// 	Com_Printf("%s is unbound, hit F4 to set.\n", Key_KeynumToString(key));
	// }

	/* While in attract loop all keys besides F1 to F12 (to
	   allow quick load and the like) are treated like escape. */
	if (cl.attractloop && (cls.key_dest != keydest_t.key_menu) &&
		!((key >= K_F1) && (key <= K_F12))) {
		key = K_ESCAPE;
	}

	/* Escape has a special meaning. Depending on the situation it
	   - pauses the game and breaks into the menu
	   - stops the attract loop and breaks into the menu
	   - closes the console and breaks into the menu
	   - moves one menu level up
	   - closes the menu
	   - closes the help computer
	   - closes the chat window
	   Fully same logic for K_JOY_BACK */
	if (cls.disable_screen == 0) {
		if (key == K_ESCAPE || key == K_JOY_BACK) {
			if (!down) {
				return;
			}

			/* Close the help computer */
			if (cl.frame.playerstate.stats[STAT_LAYOUTS] != 0 &&
				(cls.key_dest == keydest_t.key_game)) {
				Cbuf_AddText("cmd putaway\n");
				return;
			}

			switch (cls.key_dest) {
				/* Close chat window */
				case keydest_t.key_message:
	// 				Key_Message(key);
					break;

				/* Close menu or one layer up */
				case keydest_t.key_menu:
					await M_Keydown(key);
					break;

				/* Pause game and / or leave console,
				   break into the menu. */
				case keydest_t.key_game:
				case keydest_t.key_console:
					await M_Menu_Main_f([]);
					break;
			}

			return;
		}
	}

	/* This is one of the most ugly constructs I've
	   found so far in Quake II. When the game is in
	   the intermission, the player can press any key
	   to end it and advance into the next level. It
	   should be easy to figure out at server level if
	   a button is pressed. But somehow the developers
	   decided, that they'll need special move state
	   BUTTON_ANY to solve this problem. So there's
	   this global variable anykeydown. If it's not
	   0, CL_FinishMove() encodes BUTTON_ANY into the
	   button state. The server reads this value and
	   sends it to gi->ClientThink() where it's used
	   to determine if the intermission shall end.
	   Needless to say that this is the only consumer
	   of BUTTON_ANY.

	   Since we cannot alter the network protocol nor
	   the server <-> game API, I'll leave things alone
	   and try to forget. */
	if (down) {
		if (key_repeats[key] == 1) {
			anykeydown++;
		}
	} else {
		anykeydown--;
		if (anykeydown < 0) {
			anykeydown = 0;
		}
	}

	/* key up events only generate commands if the game key binding
	   is a button command (leading+ sign). These will occur even in
	   console mode, to keep the character from continuing an action
	   started before a console switch. Button commands include the
	   kenum as a parameter, so multiple downs can be matched with ups */
	if (!down) {
		final kb = keybindings[key];
		if (kb != null && (kb[0] == '+')) {
			final cmd = "-${kb.substring(1)} $key $time\n";
			Cbuf_AddText(cmd);
		}
		return;
	} else if (((cls.key_dest == keydest_t.key_menu) && menubound[key]) ||
			((cls.key_dest == keydest_t.key_console) && !consolekeys[key]) ||
			((cls.key_dest == keydest_t.key_game) && ((cls.state == connstate_t.ca_active) ||
			  !consolekeys[key]))) {
		final kb = keybindings[key];
		if (kb != null) {
			if (kb[0] == '+') {
				/* button commands add keynum and time as a parm */
				Cbuf_AddText("$kb $key $time\n");
			} else {
				Cbuf_AddText(kb);
				Cbuf_AddText("\n");
			}
		}

		return;
	}

	/* All input subsystems handled after this
	   point only care for key down events. */
	if (!down) {
		return;
	}

	/* Everything that's not a special char
	   is processed by Char_Event(). */
	if (!special) {
		return;
	}

	/* Send key to the active input subsystem */
	switch (cls.key_dest) {
		/* Chat */
		case keydest_t.key_message:
	// 		Key_Message(key);
			break;

		/* Menu */
		case keydest_t.key_menu:
			await M_Keydown(key);
			break;

		/* Console */
		case keydest_t.key_game:
		case keydest_t.key_console:
	// 		Key_Console(key);
			break;
	}
}